#!/usr/bin/env python3
"""
q: topic-based queues backed by the local filesystem.

Design goals:
- Every topic is its own FIFO queue.
- All operations are safe under contention using advisory file locks (flock).
- `get` is non-blocking by default; `--block` polls until a message exists.
- Timeouts are deliberately omitted; compose with `timeout(1)` from coreutils.

Storage layout (default):
  ${XDG_STATE_HOME:-~/.local/state}/q/
    <topic>.json        # data
    <topic>.lock        # lock (never replaced)

Override storage directory with:
  Q_DIR=/some/path q ...
or
  q --dir /some/path ...

This tool aims to be boring and script-friendly.
"""

from __future__ import annotations

import argparse
import os
import re
import shlex
import subprocess
import sys
import tempfile
import time
from pathlib import Path

from claude_q import __version__
from claude_q.core import QueueStore, default_base_dir


def _summarise(content: str, width: int = 80) -> str:
    # First line, whitespace-collapsed.
    lines = content.splitlines()
    first = lines[0] if lines else ""
    first = re.sub(r"\s+", " ", first.strip())
    if not first:
        first = "(empty)"

    more = len(lines) > 1
    # Reserve 1 char for ellipsis if needed.
    if len(first) > width:
        return first[: max(0, width - 1)] + "…"
    if more and len(first) <= width - 2:
        return first + " …"
    if more:
        return first[: max(0, width - 1)] + "…"
    return first




def _editor_cmd() -> list[str]:
    editor = os.environ.get("VISUAL") or os.environ.get("EDITOR") or "vi"
    # Allow things like: "code --wait"
    try:
        return shlex.split(editor)
    except ValueError:
        return [editor]


def _edit_text(initial: str = "") -> str:
    with tempfile.NamedTemporaryFile(
        "w+",
        encoding="utf-8",
        delete=False,
        prefix="q.",
        suffix=".txt",
    ) as tf:
        path = Path(tf.name)
        tf.write(initial)
        tf.flush()

    try:
        cmd = _editor_cmd() + [str(path)]
        proc = subprocess.run(cmd)
        if proc.returncode != 0:
            msg = (
                f"editor exited with status {proc.returncode}: {' '.join(cmd)}"
            )
            raise RuntimeError(msg)
        return path.read_text(encoding="utf-8")
    finally:
        try:
            path.unlink()
        except OSError:
            pass


def _split_topic_and_body(text: str) -> tuple[str, str]:
    if "\n" in text:
        first, rest = text.split("\n", 1)
    else:
        first, rest = text, ""
    topic = first.strip()
    if not topic:
        raise ValueError("topic is empty")
    return topic, rest


def _read_stdin_text() -> str:
    # Do not implicitly add trailing newline; preserve what we read.
    return sys.stdin.read()


def cmd_put(args: argparse.Namespace, store: QueueStore) -> int:
    if args.topic:
        topic = args.topic.strip()
        if not topic:
            raise ValueError("topic is empty")
        body = _edit_text("")
    else:
        text = _edit_text("")
        topic, body = _split_topic_and_body(text)

    uid = store.append(topic, body)
    sys.stdout.write(uid + "\n")
    return 0


def cmd_readto(args: argparse.Namespace, store: QueueStore) -> int:
    text = _read_stdin_text()
    if args.topic:
        topic = args.topic.strip()
        if not topic:
            raise ValueError("topic is empty")
        body = text
    else:
        topic, body = _split_topic_and_body(text)

    uid = store.append(topic, body)
    sys.stdout.write(uid + "\n")
    return 0


def cmd_get(args: argparse.Namespace, store: QueueStore) -> int:
    topic = args.topic.strip()
    if not topic:
        raise ValueError("topic is empty")
    sleep_s = args.poll

    while True:
        msg = store.pop_first(topic)
        if msg is not None:
            sys.stdout.write(str(msg.get("content", "")))
            sys.stdout.flush()
            return 0

        if not args.block:
            return 1

        time.sleep(sleep_s)


def cmd_peek(args: argparse.Namespace, store: QueueStore) -> int:
    topic = args.topic.strip()
    if not topic:
        raise ValueError("topic is empty")
    if args.uuid:
        msg = store.get_by_uuid(topic, args.uuid)
    else:
        msg = store.peek_first(topic)

    if msg is None:
        return 1

    sys.stdout.write(str(msg.get("content", "")))
    sys.stdout.flush()
    return 0


def cmd_list(args: argparse.Namespace, store: QueueStore) -> int:
    topic = args.topic.strip()
    if not topic:
        raise ValueError("topic is empty")
    msgs = store.list_messages(topic)
    for m in msgs:
        uid = str(m.get("uuid", ""))
        if args.quiet:
            sys.stdout.write(uid + "\n")
        else:
            summary = _summarise(str(m.get("content", "")))
            sys.stdout.write(f"{uid} {summary}\n")
    return 0


def cmd_del(args: argparse.Namespace, store: QueueStore) -> int:
    topic = args.topic.strip()
    if not topic:
        raise ValueError("topic is empty")
    ok = store.delete_by_uuid(topic, args.uuid)
    return 0 if ok else 1


def cmd_replace(args: argparse.Namespace, store: QueueStore) -> int:
    topic = args.topic.strip()
    if not topic:
        raise ValueError("topic is empty")
    body = _read_stdin_text()
    ok = store.replace_by_uuid(topic, args.uuid, body)
    return 0 if ok else 1


def cmd_edit(args: argparse.Namespace, store: QueueStore) -> int:
    topic = args.topic.strip()
    if not topic:
        raise ValueError("topic is empty")
    # Load current content (shared lock) then edit without holding any lock.
    msg = store.get_by_uuid(topic, args.uuid)
    if msg is None:
        return 1
    original = str(msg.get("content", ""))

    edited = _edit_text(original)

    ok = store.replace_by_uuid(topic, args.uuid, edited)
    return 0 if ok else 1


def _build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="q",
        description="Topic-based queues (file-backed, flock-locked).",
    )
    p.add_argument(
        "--dir",
        dest="base_dir",
        default=None,
        help="Storage directory (overrides Q_DIR and XDG_STATE_HOME).",
    )
    p.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )

    sub = p.add_subparsers(dest="cmd", required=True)

    sp = sub.add_parser(
        "put",
        help=(
            "Open $EDITOR, enqueue message. If topic omitted, first line is "
            "topic."
        ),
    )
    sp.add_argument("topic", nargs="?", help="Topic name (optional).")
    sp.set_defaults(func=cmd_put)

    sp = sub.add_parser(
        "readto",
        help=(
            "Read stdin, enqueue message. If topic omitted, first line is "
            "topic."
        ),
    )
    sp.add_argument("topic", nargs="?", help="Topic name (optional).")
    sp.set_defaults(func=cmd_readto)

    sp = sub.add_parser("get", help="Dequeue first message to stdout.")
    sp.add_argument("topic", help="Topic name.")
    sp.add_argument(
        "--block",
        action="store_true",
        help="Block (poll) until a message exists.",
    )
    sp.add_argument(
        "--poll",
        type=float,
        default=0.2,
        help="Polling interval in seconds when --block is used (default: 0.2).",
    )
    sp.set_defaults(func=cmd_get)

    sp = sub.add_parser("peek", help="Print message without removing it.")
    sp.add_argument("topic", help="Topic name.")
    sp.add_argument(
        "uuid",
        nargs="?",
        help="Message UUID (optional; defaults to first message).",
    )
    sp.set_defaults(func=cmd_peek)

    sp = sub.add_parser("list", help="List messages with UUID and a summary.")
    sp.add_argument("topic", help="Topic name.")
    sp.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Only print UUIDs (no summaries).",
    )
    sp.set_defaults(func=cmd_list)

    sp = sub.add_parser("del", help="Delete message by UUID.")
    sp.add_argument("topic", help="Topic name.")
    sp.add_argument("uuid", help="Message UUID.")
    sp.set_defaults(func=cmd_del)

    sp = sub.add_parser(
        "edit", help="Open message in $EDITOR, then replace it."
    )
    sp.add_argument("topic", help="Topic name.")
    sp.add_argument("uuid", help="Message UUID.")
    sp.set_defaults(func=cmd_edit)

    sp = sub.add_parser("replace", help="Replace message content from stdin.")
    sp.add_argument("topic", help="Topic name.")
    sp.add_argument("uuid", help="Message UUID.")
    sp.set_defaults(func=cmd_replace)

    return p


def main(argv: list[str] | None = None) -> int:
    argv = sys.argv[1:] if argv is None else argv
    parser = _build_parser()
    args = parser.parse_args(argv)

    base_dir = (
        Path(args.base_dir).expanduser()
        if args.base_dir
        else default_base_dir()
    )
    store = QueueStore(base_dir=base_dir)

    try:
        return int(args.func(args, store))
    except ValueError as e:
        sys.stderr.write(f"q: {e}\n")
        return 2
    except RuntimeError as e:
        sys.stderr.write(f"q: {e}\n")
        return 3
    except KeyboardInterrupt:
        return 130


if __name__ == "__main__":
    raise SystemExit(main())
